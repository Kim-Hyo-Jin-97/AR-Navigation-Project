# AR-Navigation-Project

- 경기 인력개발원 유니티 부트캠프에서 약 3주간 진행했던 AR 네비게이션 제작 팀 프로젝트

# 계기?

- '사람과 숲'과 협력하여 유니티를 이용한 인천시 재물포의 주요 장소(이하 POI)들을 소개하고 장소까지 가는 길을 알려주는 네비게이션 프로그램을 제작하였다.
- 총 4명의 팀을 이루어 제작하였으며 나는 길찾기 화면에 진입하면 원하는 지역의 지도와 사용자의 위치, POI의 데이터를 받아온 뒤 지도 화면을 불러오고 화면에 사용자와 POI의 위치에 맞게 마커를 띄워준 다음, POI의 마커를 띄우면 이와 관련된 정보를 보여주는 파트를 담당하였다.

# 필요했던 기능

- 2D 지도를 얻고 화면 상에 출력.
- 현재 위치 정보를 얻기 위한 GPS 정보 획득.
- POI 데이터를 불러와 저장, 활용.
- 마커를 원하는 위치에 출력하고 터치 시 상호작용 기능

# 구현 과정

우선 가장 먼저 구현할 요소들로 지도, POI, 마커를 꼽았다. 내가 담당한 파트는 2D 지도 네비게이션이고 이 파트에서 가장 핵심적인 것이 위 3가지라고 생각했기 때문이다. 특히 POI는 나 뿐만 아니라 다른 팀원들도 사용해야 했기에 어느 단계에서든 사용하기 쉽게 디자인하는 것이 중요하다고 생각했다.

- **지도 출력**
 기능은 Naver Cloud Platform을 이용하였다. 사실 게임 개발자를 지망했었고, 또 코딩을 배운지 겨우 반년도 채 되지 않았었기에 네비게이션 앱 프로젝트 자체가 모르는 것 투성이었다. 다행히 네이버에서 제공하는 map API를 이용하면 화면에 출력하는 것은 간단했다. Naver Cloud Platform에 계정을 등록한 다음 API 양식대로 제공받은 ID, PW와 함께 유니티의 WebRequest 클래스를 사용하면 지도 출력 자체는 어렵지 않았다.

  그러나 곧바로 문제가 발생하였는데 바로 유니티에서는 네이버에서 제공하는 Dynamic map을 사용할 수 없었다는 것이다. 따라서 Dynamic map이 제공하는 다양한 기능들, 특히 마커와 관련된 기능을 사용할 수 없게 되었다. 따라서 유니티에서 사용할 수 있는 Static map을 텍스처로 불러와 Raw Image에 입히고 마커는 직접 버튼을 생성하여 구현하기로 하였다.

- **POI 획득과 저장**
 은 기능 구현 자체보다도 이 것을 실제로 사용할 수 있도록 적확하게 가공하는 것이 힘들었다.
  - 먼저 POI를 저장할 컨테이너를 만들기로 했다. 우선 POI POI는 구글 스프레드 시트로 관리할 것이고 각 POI의 정보는 오름차순으로 정렬되어 있으니 컨테이너는 리스트를 사용해 구현하기로 하였다. POI값은 어디서나 불러올 수 있어야 하기 때문에 이 리스트는 static이다. 또한 값을 한번 저장하면 수정되어선 안되기 때문에 각 POI의 필드값은 private 한정자를 사용하되 값을 읽어들이는 것은 가능해야하므로 읽기 전용 프로퍼티를 제공, 마지막으로 POI 구조체의 생성자를 만들어 매개변수로 하여금 POI의 필드값을 초기화 할 수 있도록 하였다.
  - 다음으로 한 작업은 데이터가 저장된 시트를 불러와 적절히 편집한 다음 리스트 저장하는 일이었다. 이 작업은 구현의 어려움보다는 귀찮음이 더 컸다. 지도를 받아올 때와 같이 WebReqeust 클래스를 사용해서 데이터를 받아오고, 이를 POI 구조체의 매개변수에 맞게 가공하기만 하면 되는 일이다.
  -  문제는 시트에서 받아온 데이터가 내 생각만큼 깔끔하게 되어있지 않았다는 점이다. 이를테면 병합된 셀은 첫 셀에만 정상적으로 값이 출력되고 나머지 셀은 빈 칸으로 출력되거나 하는 식이다. 따라서 필요없는 문자는 빼고 어긋난 문단은 수정하는 등의 작업이 필요했다.
  
    이 부분은 노하우가 없어서 일일이 로그를 찍어가며 확인하고 다시 수정하는 작업의 반복이었다.(개인적으로는 차라리 시트를 수정하는게 편하지 않나 싶었지만 부트캠프 인원이 함께 사용하기 때문에 임의로 수정할 수는 없었다.) 어떻게 적절히 편집하고 구조체를 생성해서 리스트에 집어넣고 나면 읽어와 사용하는 것은 어렵지 않았다.

- **마커 생성**
 기능을 구현하는 것은 쉽지 않았다. 우선 "위도, 경도 데이터가 있으니, 그것을 지도의 축척, 해상도 크기와 대조해서 적절하게 유니티의 좌표로 변환하면 되지 않을까? 하는 아이디어로 출발했다. 그러나 나이브하게 간단하다고 여겼던 아이디어 단계에서와 달리 위, 경도를 변환하는 과정은 상당히 고된 작업(=구글링)이었다.
  - 우선 네이버 static map에서 사용하는 지도의 축척을 찾아봤다. 그 다음에는 지도의 확대 레벨에 따른 축척값의 변화도 알아야했다. 검색해보니 네이버에서 제공하는 static map의 축척값은 OpenStreetMap과 같았고, 확대 레벨에 따른 변화는 OpenStreetMap에서 1을 더한 것과 같았다.(전 세계를 대상으로 하는 OpenStreetMap과는 달리 한국을 중심으로 서비스하기 때문이 아닐까 싶다.)
  - OpenStreetMap에서는 확대 레벨이 1 오를 때마다 지도의 확대 수준이 2배로 늘어났다. 달리 말하면 확대 레벨이 오를 수록 (유니티 화면상에서)같은 크기가 차지하는 실제 면적이 절반씩 줄어든다는 뜻이고 따라서 확대 레벨 1일때의 축척을 x라고 할 때 x*(2^-n+1)이라고 볼 수 있다.
  - 다음은 상기한 축척에서 기준으로 잡았던 지도의 크기(=해상도)를 알아냈고 이를 우리가 사용할 지도의 크기에 맞게 수정하기로 하였다. OpenStreetMap 기준 해상도는 256x256이며 네이버 static map도 동일하다는 전제를 가지고 이를 우리가 사용할 360x800크기에 맞게 비율을 구한 다음 이 값을 아까 얻어낸 축척에 곱해주었다.
  - 1픽셀당 실제 거리값을 구했으니 이제 마커가 기준점과 어디로, 얼마나 떨어져 있는지 구할 차례다. (기준점은 지도 중앙이며 사용자의 현 위치로 가정했다.) 사실 이 부분은 평소에 지리에 관심이 없었던 것도 있고 해서 아직까지 계산식을 명확히 이해하기는 힘들었다. 그래서 계산식을 직접 설명하기보다는 계산하는데 참고했던 사이트를 첨부한다.
    
    ```bash
    https://kayuse88.github.io/haversine/ (distance)
    https://jini-story.com/204 (bearing)
    ```
    
  - 이제 픽셀당 거리와 distance를 곱하고 단위를 맞추기 위해 1000을 곱한다.(distance 공식의 결과값 단위는 km고 픽셀당 거리는 m다.) 여기에 삼각함수를 사용해 bearing으로 방향을 구한 뒤 곱해주면 POI가 가진 위도, 경도를 유니티 월드 좌표에 맞게 변환, 생성 수 있게 된다.
 
 
이상의 요소들이 가장 먼저 구현했던 작업물들이다. 지도를 먼저 구현했던 이유는 구현 자체가 쉽기도 하고, 마커가 정확한 위치에 표시되는지 확인하기 위해서였다. POI 데이터 획득과 저장은 지도 구현을 한 직후 작업했지만, 이후 팀원들과 작업물을 합치는 과정에서 여러번 수정을 거쳤다. 마커 생성 기능은 구현 자체는 상당히 까다로웠지만 한번 만들고 난 뒤에는 거의 수정할 부분이 없었다.
